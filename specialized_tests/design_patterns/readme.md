## 常用设计模式
### 创建型模式
1. **单例模式 (Singleton)**：确保一个类只有一个实例，并提供一个全局访问点。
2. **工厂方法模式 (Factory Method)**：定义一个接口用于创建对象，但由子类决定实例化哪个类。
3. **抽象工厂模式 (Abstract Factory)**：提供一个接口，用于创建相关或依赖对象的家族，而无需指定具体类。
4. **建造者模式 (Builder)**：使用多个简单对象一步步构建一个复杂的对象。
5. **原型模式 (Prototype)**：通过复制现有的实例来创建新实例，而不是通过新建。
### 结构型模式
1. **适配器模式 (Adapter)**：允许将一个类的接口转换成客户端所期待的另一个接口，从而使不兼容的接口能够合作。
2. **桥接模式 (Bridge)**：将抽象部分与实现部分分离，使它们可以独立变化。
3. **组合模式 (Composite)**：将对象组合成树形结构以表示“部分-整体”的层次结构，可以确保客户端对单个对象和组合对象的一致性使用。
4. **装饰模式 (Decorator)**：动态地给一个对象添加一些额外的职责或行为。
5. **外观模式 (Facade)**：为子系统中的一组接口提供一个一致的界面，以简化子系统的使用。
6. **享元模式 (Flyweight)**：通过共享可复用的对象来减少内存消耗和提高性能。
### 行为型模式
1. **观察者模式 (Observer)**：定义了一种一对多的依赖关系，多个观察者对象监视一个主体对象，当主体状态改变时，所有依赖于它的对象都会得到通知。
2. **策略模式 (Strategy)**：定义一组算法，将每个算法封装起来，并使它们可以互换，使算法的变化独立于使用算法的客户。
3. **命令模式 (Command)**：将请求封装为一个对象，从而使您可以用不同的请求对客户进行参数化。
4. **责任链模式 (Chain of Responsibility)**：使多个对象都有机会处理请求，从而避免请求的发送者与接受者之间的耦 合关系。
5. **状态模式 (State)**：允许对象在其内部状态改变时改变其行为。
6. **访问者模式 (Visitor)**：表示一个作用于某对象结构中的各元素的操作，而无需改变各元素的类。

## 注意事项
1. 此处涉及的是 Python 设计模式，经典设计模式还得 Java 和 C++
2. 设计模式是解决特定问题的模板，但并非万能，需要根据具体场景选择合适的模式
3. 设计模式学习起来很困难，而且需要实战经验，因此需要做到反复、多次学习
